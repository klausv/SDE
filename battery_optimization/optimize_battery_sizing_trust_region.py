"""
Battery Sizing Optimization using Trust-Region Method

Formal OR approach combining:
1. Coarse grid search (global exploration)
2. Trust-region method (local refinement)
3. Multi-start verification (robustness)

Author: Generated by Claude Code
Date: 2025-11-08
"""

import numpy as np
import pandas as pd
from scipy.optimize import minimize
import json
from pathlib import Path
from typing import Dict, Tuple, List
import time

# Import existing components
from core.lp_monthly_optimizer import MonthlyLPOptimizer
from core.economic_analysis import calculate_npv
from config import config


def evaluate_battery_npv(x: np.ndarray, prices_df: pd.DataFrame, solar_df: pd.DataFrame) -> float:
    """
    Evaluate NPV for given battery sizing (E_nom, P_max).
    
    Args:
        x: [E_nom, P_max] in kWh and kW
        prices_df: Price data with columns ['timestamp', 'price', ...]
        solar_df: Solar production data
    
    Returns:
        -NPV (negative for minimization)
    """
    E_nom, P_max = x
    
    # Parameter validation
    if E_nom < 1 or P_max < 1:
        return 1e9  # Penalty for invalid parameters
    
    # Create optimizer with these battery parameters
    optimizer = MonthlyLPOptimizer(
        config=config,
        resolution='PT60M',
        battery_kwh=E_nom,
        battery_kw=P_max
    )
    
    # Run monthly optimizations
    annual_savings = 0.0
    
    for month in range(1, 13):
        # Filter data for this month
        month_prices = prices_df[prices_df['timestamp'].dt.month == month].copy()
        month_solar = solar_df[solar_df['timestamp'].dt.month == month].copy()
        
        # Solve LP for this month
        result = optimizer.optimize_month(
            prices=month_prices['price'].values,
            solar_production=month_solar['production_kw'].values,
            timestamps=month_prices['timestamp'].values
        )
        
        if not result.success:
            return 1e9  # Penalty for infeasible solutions
        
        # Accumulate savings (negative cost = savings)
        annual_savings += -result.objective_value
    
    # Calculate NPV
    initial_cost = config.battery_cost_per_kwh * E_nom + config.battery_cost_per_kw * P_max
    
    npv = -initial_cost
    for year in range(1, 16):  # 15 years
        npv += annual_savings / (1 + config.discount_rate) ** year
    
    return -npv  # Return negative for minimization


def phase1_grid_search(
    prices_df: pd.DataFrame,
    solar_df: pd.DataFrame,
    E_grid: List[float] = None,
    P_grid: List[float] = None
) -> Tuple[pd.DataFrame, Tuple[float, float]]:
    """
    Phase 1: Coarse grid search for global exploration.
    
    Returns:
        results_df: DataFrame with columns [E_nom, P_max, NPV, time]
        best_point: (E_nom, P_max) with highest NPV
    """
    if E_grid is None:
        E_grid = [20, 40, 60, 80, 100, 120, 150, 200]
    if P_grid is None:
        P_grid = [15, 25, 35, 50, 75, 100]
    
    print("Phase 1: Grid Search")
    print(f"  E_nom grid: {E_grid}")
    print(f"  P_max grid: {P_grid}")
    print(f"  Total evaluations: {len(E_grid) * len(P_grid)}")
    
    results = []
    
    for E_nom in E_grid:
        for P_max in P_grid:
            t0 = time.time()
            npv = -evaluate_battery_npv([E_nom, P_max], prices_df, solar_df)
            elapsed = time.time() - t0
            
            results.append({
                'E_nom': E_nom,
                'P_max': P_max,
                'NPV': npv,
                'time_sec': elapsed
            })
            
            print(f"  E={E_nom:3.0f} kWh, P={P_max:3.0f} kW â†’ NPV={npv:12,.0f} NOK ({elapsed:.1f}s)")
    
    results_df = pd.DataFrame(results)
    best_idx = results_df['NPV'].idxmax()
    best_point = (results_df.loc[best_idx, 'E_nom'], results_df.loc[best_idx, 'P_max'])
    
    print(f"\nBest grid point: E={best_point[0]:.1f} kWh, P={best_point[1]:.1f} kW, NPV={results_df.loc[best_idx, 'NPV']:,.0f} NOK")
    
    return results_df, best_point


def phase2_trust_region(
    x0: Tuple[float, float],
    prices_df: pd.DataFrame,
    solar_df: pd.DataFrame,
    bounds: Tuple[Tuple[float, float], Tuple[float, float]] = None,
    method: str = 'trust-constr'
) -> Dict:
    """
    Phase 2: Trust-region refinement from best grid point.
    
    Args:
        x0: Starting point (E_nom, P_max)
        method: 'trust-constr', 'Powell', or 'COBYLA'
    
    Returns:
        Optimization result dictionary
    """
    if bounds is None:
        bounds = [(10, 250), (10, 150)]  # (E_nom bounds, P_max bounds)
    
    print(f"\nPhase 2: Trust-Region Refinement (method={method})")
    print(f"  Starting point: E={x0[0]:.1f} kWh, P={x0[1]:.1f} kW")
    
    result = minimize(
        fun=lambda x: evaluate_battery_npv(x, prices_df, solar_df),
        x0=x0,
        method=method,
        bounds=bounds,
        options={'maxiter': 30, 'disp': True}
    )
    
    optimal_npv = -result.fun
    
    print(f"\nOptimization Result:")
    print(f"  Optimal E_nom: {result.x[0]:.2f} kWh")
    print(f"  Optimal P_max: {result.x[1]:.2f} kW")
    print(f"  NPV: {optimal_npv:,.0f} NOK")
    print(f"  Function evaluations: {result.nfev}")
    print(f"  Success: {result.success}")
    print(f"  Message: {result.message}")
    
    return {
        'E_nom': result.x[0],
        'P_max': result.x[1],
        'NPV': optimal_npv,
        'nfev': result.nfev,
        'success': result.success,
        'message': result.message,
        'method': method
    }


def phase3_multistart(
    grid_results: pd.DataFrame,
    prices_df: pd.DataFrame,
    solar_df: pd.DataFrame,
    n_starts: int = 5,
    method: str = 'Powell'
) -> List[Dict]:
    """
    Phase 3: Multi-start verification from top grid points.
    
    Returns:
        List of optimization results
    """
    print(f"\nPhase 3: Multi-Start Verification (n={n_starts}, method={method})")
    
    # Get top N grid points
    top_points = grid_results.nlargest(n_starts, 'NPV')
    
    results = []
    
    for idx, row in top_points.iterrows():
        x0 = (row['E_nom'], row['P_max'])
        print(f"\n  Start {len(results)+1}/{n_starts}: E={x0[0]:.1f} kWh, P={x0[1]:.1f} kW")
        
        opt_result = phase2_trust_region(
            x0=x0,
            prices_df=prices_df,
            solar_df=solar_df,
            method=method
        )
        
        results.append(opt_result)
    
    # Find best across all starts
    best_result = max(results, key=lambda r: r['NPV'])
    
    print(f"\n=== Best Solution Across All Starts ===")
    print(f"  E_nom: {best_result['E_nom']:.2f} kWh")
    print(f"  P_max: {best_result['P_max']:.2f} kW")
    print(f"  NPV: {best_result['NPV']:,.0f} NOK")
    
    return results


def main():
    """Run complete three-phase optimization."""
    
    # Load data (placeholder - adapt to your data loading)
    print("Loading data...")
    # prices_df = pd.read_csv('data/spot_prices/NO2_2024_60min_real.csv')
    # solar_df = pd.read_csv('data/solar_production.csv')
    
    # For now, create dummy data structure
    print("ERROR: Please implement data loading in main()")
    print("Expected columns:")
    print("  prices_df: ['timestamp', 'price']")
    print("  solar_df: ['timestamp', 'production_kw']")
    return
    
    # Phase 1: Grid search
    grid_results, best_grid_point = phase1_grid_search(prices_df, solar_df)
    
    # Save grid results
    grid_results.to_csv('results/battery_sizing_grid_search.csv', index=False)
    
    # Phase 2: Trust-region from best grid point
    trust_result = phase2_trust_region(
        x0=best_grid_point,
        prices_df=prices_df,
        solar_df=solar_df,
        method='trust-constr'
    )
    
    # Phase 3: Multi-start verification
    multistart_results = phase3_multistart(
        grid_results=grid_results,
        prices_df=prices_df,
        solar_df=solar_df,
        n_starts=5,
        method='Powell'
    )
    
    # Save final results
    final_results = {
        'grid_search': grid_results.to_dict('records'),
        'trust_region': trust_result,
        'multistart': multistart_results
    }
    
    with open('results/battery_sizing_trust_region_results.json', 'w') as f:
        json.dump(final_results, f, indent=2)
    
    print("\n=== Optimization Complete ===")
    print("Results saved to results/battery_sizing_trust_region_results.json")


if __name__ == '__main__':
    main()
